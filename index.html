<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>KAIJU 3D: City Smasher</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            font-family: 'Arial Black', sans-serif; pointer-events: none;
            text-shadow: 2px 2px 0 #000;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px; border: 2px solid red; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            background: rgba(255, 0, 0, 0.3);
        }
        #controls-hint {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: white; font-family: sans-serif; font-weight: bold; text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui">
        <h1 style="margin:0; font-size: 30px;"> KAIJU 3D</h1>
        <p style="margin:0; font-size: 20px;">Edificios: <span id="score">0</span></p>
    </div>
    
    <div id="crosshair"></div>
    <div id="controls-hint">PC: WASD Mover | CLICK Disparar <br> MVIL: Toca lados para girar | Toca centro para avanzar</div>

    <script>
        // --- CONFIGURACIN BSICA ---
        let scene, camera, renderer;
        let bullets = [];
        let buildings = [];
        let particles = [];
        let civilians = [];
        let score = 0;
        
        // Variables de movimiento
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canShoot = true;
        
        // Configuraci贸n del Jugador (Dino)
        let player = { height: 15, speed: 0.8, rotationSpeed: 0.03 };

        function init() {
            // 1. Escena y Cielo
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Cielo Azul
            scene.fog = new THREE.Fog(0x87CEEB, 20, 150); // Niebla para profundidad

            // 2. C谩mara (Ojos del Dino)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = player.height; // Altura de gigante

            // 3. Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Sombras activadas
            document.body.appendChild(renderer.domElement);

            // 4. Luz (Sol)
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6); // Luz suave
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            // 5. Suelo (Ciudad)
            const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // 6. Generar Ciudad (Edificios)
            generateCity();

            // 7. Generar Civiles (Puntos que corren)
            generateCivilians();

            // 8. Eventos de Control
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', shoot);
            document.addEventListener('touchstart', handleTouch);
            window.addEventListener('resize', onWindowResize);

            // Arma visual (Bazooka)
            createBazooka();

            animate();
        }

        // --- GENERADOR DE CIUDAD ---
        function generateCity() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            
            // Colores de edificios
            const colors = [0x95a5a6, 0xbdc3c7, 0x34495e, 0xf1c40f, 0xe74c3c, 0x3498db];

            for (let i = 0; i < 150; i++) {
                // Elegir color y tama帽o
                const color = colors[Math.floor(Math.random() * colors.length)];
                const material = new THREE.MeshStandardMaterial({ color: color });
                const building = new THREE.Mesh(geometry, material);

                // Tama帽o aleatorio (Rascacielos vs Casas)
                const width = 5 + Math.random() * 10;
                const depth = 5 + Math.random() * 10;
                const height = 10 + Math.random() * 40; // Altura

                building.scale.set(width, height, depth);

                // Posici贸n aleatoria (evitando el centro donde empezamos)
                let x = (Math.random() - 0.5) * 400;
                let z = (Math.random() - 0.5) * 400;
                
                // Zona segura inicial
                if (Math.abs(x) < 20 && Math.abs(z) < 20) x += 30;

                building.position.set(x, height / 2, z);
                building.castShadow = true;
                building.receiveShadow = true;

                // Datos propios del edificio para l贸gica
                building.userData = { hp: 3, type: 'building' }; 

                scene.add(building);
                buildings.push(building);
            }
        }

        // --- BAZOOKA VISUAL ---
        let bazooka;
        function createBazooka() {
            const geometry = new THREE.CylinderGeometry(0.5, 0.8, 4, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            bazooka = new THREE.Mesh(geometry, material);
            bazooka.rotation.x = Math.PI / 2;
            bazooka.position.set(2, -1, -3); // A la derecha y abajo de la c谩mara
            camera.add(bazooka); // Pegar a la c谩mara
            scene.add(camera);
        }

        // --- DISPARAR ---
        function shoot() {
            if(!canShoot) return;
            
            // Efecto retroceso
            bazooka.position.z += 0.5;
            setTimeout(() => bazooka.position.z -= 0.5, 100);

            // Crear Cohete
            const geometry = new THREE.SphereGeometry(0.8, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Rojo brillante
            const bullet = new THREE.Mesh(geometry, material);

            // Posici贸n inicial (punta del bazooka)
            bullet.position.copy(camera.position);
            bullet.position.y -= 1; // Ajuste leve
            
            // Direcci贸n
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            bullet.userData = { velocity: direction.multiplyScalar(2) }; // Velocidad r谩pida

            scene.add(bullet);
            bullets.push(bullet);
        }

        // --- CIVILES ---
        function generateCivilians() {
            const geo = new THREE.SphereGeometry(0.5, 4, 4);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            
            for(let i=0; i<50; i++) {
                const civ = new THREE.Mesh(geo, mat);
                civ.position.set((Math.random()-0.5)*100, 1, (Math.random()-0.5)*100);
                civ.userData = { speed: 0.2, direction: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize() };
                civilians.push(civ);
                scene.add(civ);
            }
        }

        // --- CONTROLES ---
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
            }
        }
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }
        function handleTouch(e) {
            // Control simple t谩ctil
            if(e.touches[0].clientX > window.innerWidth / 2) shoot();
            else {
                // Avanzar simple al tocar izquierda
                moveForward = true;
                setTimeout(()=> moveForward=false, 200);
            }
        }

        // --- FSICA Y LGICA DE JUEGO ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Mover Jugador
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const sideDirection = new THREE.Vector3().crossVectors(camera.up, direction).normalize();

            if (moveForward) camera.position.add(direction.multiplyScalar(player.speed));
            if (moveBackward) camera.position.add(direction.multiplyScalar(-player.speed));
            if (moveRight) camera.rotation.y -= player.rotationSpeed;
            if (moveLeft) camera.rotation.y += player.rotationSpeed;

            // Mantener altura (no volar)
            camera.position.y = player.height;

            // 2. Mover Balas
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                b.position.add(b.userData.velocity);

                // Detectar Colisiones con Edificios
                let hit = false;
                for (let j = buildings.length - 1; j >= 0; j--) {
                    let build = buildings[j];
                    // Distancia simple (Hitbox circular)
                    let dist = b.position.distanceTo(build.position);
                    
                    // Colisi贸n aproximada
                    if (dist < Math.max(build.scale.x, build.scale.z) / 1.5 + 1) {
                        createExplosion(b.position, 0xff5500, 10); // Explosi贸n de impacto
                        createExplosion(b.position, 0x888888, 5);  // Humo
                        
                        // Eliminar bala
                        scene.remove(b);
                        bullets.splice(i, 1);
                        hit = true;

                        // Da帽ar edificio
                        build.userData.hp--;
                        // Flash blanco al golpear
                        build.material.emissive.setHex(0xffffff);
                        setTimeout(() => build.material.emissive.setHex(0x000000), 50);

                        if (build.userData.hp <= 0) {
                            destroyBuilding(build, j);
                        }
                        break;
                    }
                }
                
                // Eliminar balas lejanas
                if (!hit && b.position.distanceTo(camera.position) > 200) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                }
            }

            // 3. Part铆culas (Escombros)
            updateParticles();

            // 4. Civiles corriendo
            civilians.forEach(civ => {
                civ.position.add(civ.userData.direction.multiplyScalar(civ.userData.speed));
                // Cambiar direcci贸n random
                if(Math.random() > 0.95) civ.userData.direction = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                // Si se alejan mucho, volver al centro
                if(civ.position.length() > 200) civ.position.set(0,1,0);
            });

            renderer.render(scene, camera);
        }

        // --- DESTRUCCIN ---
        function destroyBuilding(building, index) {
            // Efecto masivo
            createExplosion(building.position, building.material.color.getHex(), 30); // Escombros del color del edificio
            createExplosion(building.position, 0xff0000, 20); // Fuego

            // Sacudir c谩mara (Screen Shake)
            camera.position.y -= 2;
            setTimeout(()=> camera.position.y += 2, 50);

            // Eliminar edificio real
            scene.remove(building);
            buildings.splice(index, 1);

            score++;
            document.getElementById('score').innerText = score;
        }

        function createExplosion(pos, color, count) {
            const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshBasicMaterial({ color: color });

            for (let i = 0; i < count; i++) {
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(pos);
                // Dispersi贸n aleatoria
                p.position.x += (Math.random() - 0.5) * 5;
                p.position.y += (Math.random() - 0.5) * 10;
                p.position.z += (Math.random() - 0.5) * 5;
                
                // Velocidad
                p.userData = {
                    vel: new THREE.Vector3((Math.random()-0.5), (Math.random()), (Math.random()-0.5)),
                    life: 60
                };
                scene.add(p);
                particles.push(p);
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.position.add(p.userData.vel);
                p.userData.vel.y -= 0.05; // Gravedad
                p.userData.life--;
                p.rotation.x += 0.1;
                
                if (p.position.y < 0) p.userData.vel.y *= -0.5; // Rebotar en suelo

                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>